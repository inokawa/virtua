import{c as N,d as k,s as I,v as E,D as V,o as B,K as F,L as Y,M as Q,n as X,A as O,h as _,j as R,B as x,k as e,N as r,i as Z,C as w,G as C,H as $}from"./props-EeEA5hs9.js";import{d as ee,p as te,q as ie,U as ne,h as se,j as ae,e as re,l as oe,n as le,A as de,L as ce,c as W,s as ue}from"./ListItem-DYoJ05TO.js";var fe=x("<div></div>");function p(b,t){N(t,!0);let v=k(t,"getKey",3,oe),h=k(t,"shift",3,!1),s=k(t,"horizontal",3,!1);const i=ee(t.data.length,t.itemSize,t.overscan,void 0,void 0,!t.itemSize),c=te(i,s()),o=ie(i,s()),l=i.$subscribe(ne,()=>{I(n,E(i.$getStateVersion()))}),u=i.$subscribe(se,()=>{t.onscroll&&t.onscroll()}),g=i.$subscribe(ae,()=>{t.onscrollend&&t.onscrollend()});let a=V(void 0),n=V(E(i.$getStateVersion())),K=r(()=>e(n)&&i.$getRange()),U=r(()=>e(n)&&i.$isScrolling()),S=r(()=>e(n)&&i.$getTotalSize()),z=r(()=>e(n)&&i.$getJumpCount());B(()=>{c.$observeRoot(e(a)),o.$observe(e(a))}),F(()=>{l(),u(),g(),c.$dispose(),o.$dispose()}),Y(()=>{t.data.length!==i.$getItemsLength()&&i.$update(de,[t.data.length,h()])});let T;Q(()=>{T!==e(z)&&(T=e(z),o.$fixScrollJump())});const j=i.$findStartIndex,G=i.$findEndIndex,q=o.$scrollToIndex;let H=r(()=>ue({"overflow-anchor":"none",flex:"none",position:"relative",visibility:"hidden",width:s()?e(S)+"px":"100%",height:s()?"100%":e(S)+"px","pointer-events":e(U)?"none":void 0}));var f=fe();return X(f,d=>I(a,d),()=>e(a)),re(f,21,()=>le(e(K)),d=>v()(t.data[d],d),(d,m)=>{const J=r(()=>t.data[e(m)]);var M=r(()=>e(n)&&i.$getItemOffset(e(m))),P=r(()=>e(n)&&i.$isUnmeasuredItem(e(m)));ce(d,{get children(){return t.children},get item(){return e(J)},get index(){return e(m)},as:"div",get offset(){return e(M)},get hide(){return e(P)},get horizontal(){return s()},get resizer(){return c.$observeItem}})}),O(()=>W(f,"style",e(H))),_(b,f),R({findStartIndex:j,findEndIndex:G,scrollToIndex:q})}p.__docgen={data:[{name:"data",visibility:"public",description:"The data items rendered by this component.",keywords:[{name:"required",description:""}],kind:"let",type:{kind:"type",type:"array",text:"T[]"},static:!1,readonly:!1},{name:"children",visibility:"public",description:"The elements renderer snippet.",keywords:[{name:"required",description:""}],kind:"let",type:{kind:"function",text:"Snippet<[item: T, index: number]>"},static:!1,readonly:!1},{name:"getKey",visibility:"public",description:"Function that returns the key of an item in the list. It's recommended to specify whenever possible for performance.",keywords:[],kind:"let",type:{kind:"function",text:"(data: T, index: number) => string | number"},static:!1,readonly:!1,defaultValue:"function"},{name:"overscan",visibility:"public",description:"Number of items to render above/below the visible bounds of the list. You can increase to avoid showing blank items in fast scrolling.",keywords:[],kind:"let",type:{kind:"type",type:"number",text:"number"},static:!1,readonly:!1},{name:"itemSize",visibility:"public",description:`Item size hint for unmeasured items. It will help to reduce scroll jump when items are measured if used properly.

- If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.
- If set, you can opt out estimation and use the value as initial item size.`,keywords:[],kind:"let",type:{kind:"type",type:"number",text:"number"},static:!1,readonly:!1},{name:"shift",visibility:"public",description:"While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1,defaultValue:"false"},{name:"horizontal",visibility:"public",description:"If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1,defaultValue:"false"},{name:"onscroll",visibility:"public",description:"Callback invoked whenever scroll offset changes.",keywords:[],kind:"let",type:{kind:"function",text:"() => void"},static:!1,readonly:!1},{name:"onscrollend",visibility:"public",description:"Callback invoked when scrolling stops.",keywords:[],kind:"let",type:{kind:"function",text:"() => void"},static:!1,readonly:!1}],name:"WindowVirtualizer.svelte"};var me=x("<div> </div>"),ye=x('<div style="padding: 200px 100px;"><div style="border: solid 1px gray;"><!></div></div>');function pe(b,t){N(t,!1);const v=[20,40,180,77],h=Array.from({length:1e3}).map((o,l)=>v[l%4]);Z();var s=ye(),i=w(s),c=w(i);p(c,{data:h,getKey:(l,u)=>u,children:(l,u=C,g=C)=>{var a=me(),n=w(a);O(()=>{W(a,"style",`
            height: ${u()??""}px;
            background: white;
            border-bottom: solid 1px #ccc;
          `),$(n,g())}),_(l,a)},$$slots:{default:!0}}),_(b,s),R()}p.__docgen={keywords:[],data:[],name:"WindowVirtualizer.svelte"};const he={component:p},y={render:()=>({Component:pe})};var A,L,D;y.parameters={...y.parameters,docs:{...(A=y.parameters)==null?void 0:A.docs,source:{originalSource:`{
  render: () => ({
    Component: DefaultComponent
  })
}`,...(D=(L=y.parameters)==null?void 0:L.docs)==null?void 0:D.source}}};const ge=["Default"];export{y as Default,ge as __namedExportsOrder,he as default};
