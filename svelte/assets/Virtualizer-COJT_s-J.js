import{x as d,i as v,y as k,z as X,v as S,w,a as x,b as Z,d as $,s as z,m as ee,g as i,t as te,A as s}from"./iframe-w03tklGc.js";import{g as ie,h as ne,j as se,U as re,k as ae,l as le,o as oe,m as de,n as ce,p as fe,q as ue,A as me,r as ye,b as be,a as pe,e as ge,t as he,s as ve,L as ke}from"./legacy-BylLanIJ.js";function Se(T,t){$(t,!0);let I=d(t,"getKey",3,ue),_=d(t,"as",3,"div"),E=d(t,"shift",3,!1),l=d(t,"horizontal",3,!1),y=d(t,"startMargin",3,0);const e=ie(t.data.length,t.itemSize,t.overscan,void 0,void 0,!t.itemSize),u=ne(e,l()),r=se(e,l()),V=e.$subscribe(re,()=>{v(n,e.$getStateVersion(),!0)}),O=e.$subscribe(ae,()=>{t.onscroll&&t.onscroll(e.$getScrollOffset())}),R=e.$subscribe(le,()=>{t.onscrollend&&t.onscrollend()});let m=z(void 0),n=z(ee(e.$getStateVersion())),A=s(()=>i(n)&&e.$getRange()),C=s(()=>i(n)&&e.$isScrolling()),b=s(()=>i(n)&&e.$getTotalSize());oe(()=>{const o=c=>{u.$observeRoot(c),r.$observe(c)};te().then(()=>{t.scrollRef?o(t.scrollRef):o(i(m).parentElement)})}),de(()=>{V(),O(),R(),u.$dispose(),r.$dispose()}),k(()=>{t.data.length!==e.$getItemsLength()&&e.$update(me,[t.data.length,E()])}),k(()=>{y()!==e.$getStartSpacerSize()&&e.$update(ye,y())});let p;X(()=>{p!==i(n)&&(p=i(n),r.$fixScrollJump())});const L=e.$getScrollOffset,N=()=>fe(e),M=e.$getViewportSize,U=e.$findStartIndex,D=e.$findEndIndex,G=e.$getItemOffset,H=e.$getItemSize,K=r.$scrollToIndex,j=r.$scrollTo,q=r.$scrollBy;let F=s(()=>ve({contain:"strict","overflow-anchor":"none",overflow:"clip",flex:"none",position:"relative",width:l()?i(b)+"px":"100%",height:l()?"100%":i(b)+"px","pointer-events":i(C)?"none":void 0}));var P={getScrollOffset:L,getScrollSize:N,getViewportSize:M,findStartIndex:U,findEndIndex:D,getItemOffset:G,getItemSize:H,scrollToIndex:K,scrollTo:j,scrollBy:q},g=S(),B=w(g);return ce(B,_,!1,(o,c)=>{be(o,a=>v(m,a,!0),()=>i(m)),pe(o,()=>({style:i(F)}));var h=S(),J=w(h);ge(J,17,()=>he(i(A)),a=>I()(t.data[a],a),(a,f)=>{const W=s(()=>t.data[i(f)]);{let Y=s(()=>i(n)&&e.$getItemOffset(i(f))),Q=s(()=>i(n)&&e.$isUnmeasuredItem(i(f)));ke(a,{get children(){return t.children},get item(){return i(W)},get index(){return i(f)},get as(){return t.item},get offset(){return i(Y)},get hide(){return i(Q)},get horizontal(){return l()},get resizer(){return u.$observeItem}})}}),x(c,h)}),x(T,g),Z(P)}Se.__docgen={data:[{name:"data",visibility:"public",description:"The data items rendered by this component.",keywords:[{name:"required",description:""}],kind:"let",type:{kind:"type",type:"array",text:"T[]"},static:!1,readonly:!1},{name:"children",visibility:"public",description:"The elements renderer snippet.",keywords:[{name:"required",description:""}],kind:"let",type:{kind:"function",text:"Snippet<[item: T, index: number]>"},static:!1,readonly:!1},{name:"getKey",visibility:"public",description:"Function that returns the key of an item in the list. It's recommended to specify whenever possible for performance.",keywords:[],kind:"let",type:{kind:"function",text:"(data: T, index: number) => string | number"},static:!1,readonly:!1,defaultValue:"function"},{name:"as",visibility:"public",description:"Component or element type for container element.",keywords:[],kind:"let",type:{kind:"union",type:[{kind:"type",type:"string",text:"string"},{kind:"type",type:"number",text:"number"}],text:"string | number"},static:!1,readonly:!1,defaultValue:'"div"'},{name:"item",visibility:"public",description:"Component or element type for item element.",keywords:[],kind:"let",type:{kind:"union",type:[{kind:"type",type:"string",text:"string"},{kind:"type",type:"number",text:"number"}],text:"string | number"},static:!1,readonly:!1},{name:"overscan",visibility:"public",description:"Number of items to render above/below the visible bounds of the list. You can increase to avoid showing blank items in fast scrolling.",keywords:[],kind:"let",type:{kind:"type",type:"number",text:"number"},static:!1,readonly:!1},{name:"scrollRef",visibility:"public",description:"Reference to the scrollable element. The default will get the direct parent element of virtualizer.",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"HTMLElement"},static:!1,readonly:!1},{name:"itemSize",visibility:"public",description:`Item size hint for unmeasured items. It will help to reduce scroll jump when items are measured if used properly.

- If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.
- If set, you can opt out estimation and use the value as initial item size.`,keywords:[],kind:"let",type:{kind:"type",type:"number",text:"number"},static:!1,readonly:!1},{name:"shift",visibility:"public",description:"While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1,defaultValue:"false"},{name:"horizontal",visibility:"public",description:"If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1,defaultValue:"false"},{name:"startMargin",visibility:"public",description:"If you put an element before virtualizer, you have to define its height with this prop.",keywords:[],kind:"let",type:{kind:"type",type:"number",text:"number"},static:!1,readonly:!1,defaultValue:"0"},{name:"onscroll",visibility:"public",description:"Callback invoked whenever scroll offset changes.",keywords:[],kind:"let",type:{kind:"function",text:"(offset: number) => void"},static:!1,readonly:!1},{name:"onscrollend",visibility:"public",description:"Callback invoked when scrolling stops.",keywords:[],kind:"let",type:{kind:"function",text:"() => void"},static:!1,readonly:!1}],name:"Virtualizer.svelte"};export{Se as V};
