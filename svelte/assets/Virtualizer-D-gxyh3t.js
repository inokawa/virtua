import{c as $,d,s as w,v as y,D as T,o as ee,K as te,L as x,M as ie,f as z,g as I,h as _,j as ne,k as i,n as se,A as ae,N as n,O as re}from"./props-EeEA5hs9.js";import{d as le,f as oe,g as de,U as ce,h as fe,j as ue,k as me,l as ye,m as be,e as pe,n as ge,A as he,o as ve,b as ke,L as Se,s as we}from"./ListItem-Cpka-yUq.js";function Te(E,t){$(t,!0);let V=d(t,"getKey",3,ye),O=d(t,"as",3,"div"),R=d(t,"shift",3,!1),o=d(t,"horizontal",3,!1),b=d(t,"startMargin",3,0);const e=le(t.data.length,t.itemSize,t.overscan,void 0,void 0,!t.itemSize),u=oe(e,o()),r=de(e,o()),A=e.$subscribe(ce,()=>{w(s,y(e.$getStateVersion()))}),C=e.$subscribe(fe,()=>{t.onscroll&&t.onscroll(e.$getScrollOffset())}),N=e.$subscribe(ue,()=>{t.onscrollend&&t.onscrollend()});let m=T(void 0),s=T(y(e.$getStateVersion())),L=n(()=>i(s)&&e.$getRange()),M=n(()=>i(s)&&e.$isScrolling()),p=n(()=>i(s)&&e.$getTotalSize()),g=n(()=>i(s)&&e.$getJumpCount());ee(()=>{const a=c=>{u.$observeRoot(c),r.$observe(c)};t.scrollRef?a(t.scrollRef):a(i(m).parentElement)}),te(()=>{A(),C(),N(),u.$dispose(),r.$dispose()}),x(()=>{t.data.length!==e.$getItemsLength()&&e.$update(he,[t.data.length,R()])}),x(()=>{b()!==e.$getStartSpacerSize()&&e.$update(ve,b())});let h;ie(()=>{h!==i(g)&&(h=i(g),r.$fixScrollJump())});const U=e.$getScrollOffset,D=()=>be(e),j=e.$getViewportSize,G=e.$findStartIndex,K=e.$findEndIndex,H=e.$getItemOffset,P=e.$getItemSize,F=r.$scrollToIndex,J=r.$scrollTo,q=r.$scrollBy;let B=n(()=>we({"overflow-anchor":"none",flex:"none",position:"relative",visibility:"hidden",width:o()?i(p)+"px":"100%",height:o()?"100%":i(p)+"px","pointer-events":i(M)?"none":void 0}));var v=z(),W=I(v);return me(W,O,!1,(a,c)=>{se(a,l=>w(m,y(l)),()=>i(m));let k;ae(()=>k=ke(a,k,{style:i(B)},void 0,a.namespaceURI===re,a.nodeName.includes("-")));var S=z(),Y=I(S);pe(Y,17,()=>ge(i(L)),l=>V()(t.data[l],l),(l,f)=>{const Q=n(()=>t.data[i(f)]);var X=n(()=>i(s)&&e.$getItemOffset(i(f))),Z=n(()=>i(s)&&e.$isUnmeasuredItem(i(f)));Se(l,{get children(){return t.children},get item(){return i(Q)},get index(){return i(f)},get as(){return t.item},get offset(){return i(X)},get hide(){return i(Z)},get horizontal(){return o()},get resizer(){return u.$observeItem}})}),_(c,S)}),_(E,v),ne({getScrollOffset:U,getScrollSize:D,getViewportSize:j,findStartIndex:G,findEndIndex:K,getItemOffset:H,getItemSize:P,scrollToIndex:F,scrollTo:J,scrollBy:q})}Te.__docgen={data:[{name:"data",visibility:"public",description:"The data items rendered by this component.",keywords:[{name:"required",description:""}],kind:"let",type:{kind:"type",type:"array",text:"T[]"},static:!1,readonly:!1},{name:"children",visibility:"public",description:"The elements renderer snippet.",keywords:[{name:"required",description:""}],kind:"let",type:{kind:"function",text:"Snippet<[item: T, index: number]>"},static:!1,readonly:!1},{name:"getKey",visibility:"public",description:"Function that returns the key of an item in the list. It's recommended to specify whenever possible for performance.",keywords:[],kind:"let",type:{kind:"function",text:"(data: T, index: number) => string | number"},static:!1,readonly:!1,defaultValue:"function"},{name:"as",visibility:"public",description:"Component or element type for container element.",keywords:[],kind:"let",type:{kind:"union",type:[{kind:"type",type:"string",text:"string"},{kind:"type",type:"number",text:"number"}],text:"string | number"},static:!1,readonly:!1,defaultValue:'"div"'},{name:"item",visibility:"public",description:"Component or element type for item element.",keywords:[],kind:"let",type:{kind:"union",type:[{kind:"type",type:"string",text:"string"},{kind:"type",type:"number",text:"number"}],text:"string | number"},static:!1,readonly:!1},{name:"overscan",visibility:"public",description:"Number of items to render above/below the visible bounds of the list. You can increase to avoid showing blank items in fast scrolling.",keywords:[],kind:"let",type:{kind:"type",type:"number",text:"number"},static:!1,readonly:!1},{name:"scrollRef",visibility:"public",description:"Reference to the scrollable element. The default will get the direct parent element of virtualizer.",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"HTMLElement"},static:!1,readonly:!1},{name:"itemSize",visibility:"public",description:`Item size hint for unmeasured items. It will help to reduce scroll jump when items are measured if used properly.

- If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.
- If set, you can opt out estimation and use the value as initial item size.`,keywords:[],kind:"let",type:{kind:"type",type:"number",text:"number"},static:!1,readonly:!1},{name:"shift",visibility:"public",description:"While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1,defaultValue:"false"},{name:"horizontal",visibility:"public",description:"If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1,defaultValue:"false"},{name:"startMargin",visibility:"public",description:"If you put an element before virtualizer, you have to define its height with this prop.",keywords:[],kind:"let",type:{kind:"type",type:"number",text:"number"},static:!1,readonly:!1,defaultValue:"0"},{name:"onscroll",visibility:"public",description:"Callback invoked whenever scroll offset changes.",keywords:[],kind:"let",type:{kind:"function",text:"(offset: number) => void"},static:!1,readonly:!1},{name:"onscrollend",visibility:"public",description:"Callback invoked when scrolling stops.",keywords:[],kind:"let",type:{kind:"function",text:"() => void"},static:!1,readonly:!1}],name:"Virtualizer.svelte"};export{Te as V};
