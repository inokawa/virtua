import{c as A,p as a,o as L,a as N,t as z,s as i,i as _,b as y,F as O,d as R,v as H,r as I,j as D,g as U}from"./iframe-D0JkJ_s3.js";import{c as P,h as j,U as G,b as M,d as F,L as J,j as Y,i as B,A as K}from"./utils-CKjnA6S-.js";var Q=z("<div style=overflow-anchor:none>");const b=n=>{let d;const{ref:u,data:f,children:w,itemSize:g,shift:m,horizontal:h=!1,cache:x,onScrollEnd:ee}=n,e=P(n.data.length,g,void 0,x,!g),S=Y(e,h),p=j(e,h),[s,T]=A(e.$getStateVersion());e.$subscribe(G,()=>{T(e.$getStateVersion())}),e.$subscribe(M,()=>{n.onScroll?.()}),e.$subscribe(F,()=>{n.onScrollEnd?.()});const $=a(t=>{s();const o=e.$getRange(n.bufferSize);return t&&B(t,o)?t:o}),E=a(()=>s()&&e.$isScrolling()),V=a(()=>s()&&e.$getTotalSize()),k=a(()=>s()&&p.$isNegative());L(()=>{n.ref&&n.ref({get cache(){return e.$getCacheSnapshot()},get scrollOffset(){return e.$getScrollOffset()},get viewportSize(){return e.$getViewportSize()},findItemIndex:e.$findItemIndex,getItemOffset:e.$getItemOffset,getItemSize:e.$getItemSize,scrollToIndex:p.$scrollToIndex}),S.$observeRoot(d),p.$observe(d),U(()=>{n.ref&&n.ref(),e.$dispose(),S.$dispose(),p.$dispose()})}),N(H(s,()=>{p.$fixScrollJump()}));const C=a(()=>{const t=n.data.length;I(()=>{t!==e.$getItemsLength()&&e.$update(K,[t,n.shift])});const o=[];for(let[r,c]=$();r<=c;r++)o.push(n.data[r]);return o});return(()=>{var t=Q(),o=d;return typeof o=="function"?D(o,t):d=t,i(t,"contain","size style"),i(t,"flex","none"),i(t,"position","relative"),_(t,y(O,{get each(){return C()},children:(r,c)=>{const l=a(()=>$()[0]+c()),v=a(()=>(s(),e.$getItemOffset(l(),k()))),W=a(()=>(s(),e.$isUnmeasuredItem(l()))),q=a(()=>I(()=>n.children(r,l)));return y(J,{get _index(){return l()},get _resizer(){return S.$observeItem},get _offset(){return v()},get _hide(){return W()},get _children(){return q()},_isHorizontal:h})}})),R(r=>{var c=h?V()+"px":"100%",l=h?"100%":V()+"px",v=E()?"none":void 0;return c!==r.e&&i(t,"width",r.e=c),l!==r.t&&i(t,"height",r.t=l),v!==r.a&&i(t,"pointer-events",r.a=v),r},{e:void 0,t:void 0,a:void 0}),t})()};try{b.displayName="WindowVirtualizer",b.__docgenInfo={description:"{@link Virtualizer } controlled by the window scrolling. See {@link WindowVirtualizerProps} and {@link WindowVirtualizerHandle}.",displayName:"WindowVirtualizer",props:{ref:{defaultValue:null,description:"Get reference to {@link WindowVirtualizerHandle}.",name:"ref",required:!1,type:{name:"((handle?: WindowVirtualizerHandle | undefined) => void) | undefined"}},data:{defaultValue:null,description:"The data items rendered by this component.",name:"data",required:!0,type:{name:"readonly T[]"}},children:{defaultValue:null,description:"The elements renderer function.",name:"children",required:!0,type:{name:"(data: T, index: Accessor<number>) => Element"}},bufferSize:{defaultValue:null,description:`Extra item space in pixels to render before/after the viewport. The minimum value is 0. Lower value will give better performance but you can increase to avoid showing blank items in fast scrolling.
@defaultValue 200`,name:"bufferSize",required:!1,type:{name:"number | undefined"}},itemSize:{defaultValue:null,description:`Item size hint for unmeasured items in pixels. It will help to reduce scroll jump when items are measured if used properly.

- If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.
- If set, you can opt out estimation and use the value as initial item size.`,name:"itemSize",required:!1,type:{name:"number | undefined"}},shift:{defaultValue:null,description:"While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.",name:"shift",required:!1,type:{name:"boolean | undefined"}},horizontal:{defaultValue:null,description:"If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.",name:"horizontal",required:!1,type:{name:"boolean | undefined"}},cache:{defaultValue:null,description:`You can restore cache by passing a {@link CacheSnapshot} on mount. This is useful when you want to restore scroll position after navigation. The snapshot can be obtained from {@link WindowVirtualizerHandle.cache}.

**The length of items should be the same as when you take the snapshot, otherwise restoration may not work as expected.**`,name:"cache",required:!1,type:{name:"CacheSnapshot | undefined"}},onScroll:{defaultValue:null,description:"Callback invoked whenever scroll offset changes.",name:"onScroll",required:!1,type:{name:"(() => void) | undefined"}},onScrollEnd:{defaultValue:null,description:"Callback invoked when scrolling stops.",name:"onScrollEnd",required:!1,type:{name:"(() => void) | undefined"}}}}}catch{}var X=z("<div><div>"),Z=z('<div style="border-bottom:solid 1px #ccc">');const re={component:b},ie={render:()=>{const n=[20,40,80,77],d=Array.from({length:1e3}).map((u,f)=>n[f%4]);return(()=>{var u=X(),f=u.firstChild;return i(u,"padding","200px 100px"),i(f,"border","solid 1px gray"),_(f,y(b,{data:d,children:(w,g)=>(()=>{var m=Z();return i(m,"height",w+"px"),i(m,"background","#fff"),_(m,g),m})()})),u})()}},ae=["Default"];export{ie as Default,ae as __namedExportsOrder,re as default};
