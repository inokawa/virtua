import{m as E,c as C,l as i,o as x,n as k,p as q,a as h,F as R,D as L,q as z,r as v,v as A}from"./iframe-BBNxMJoV.js";import{c as N,a as O,U as M,b as H,d as D,e as U,L as P,i as F,A as G,s as j,g as B,f as J}from"./utils-BXTnjP0h.js";const V=t=>{let f;const{itemSize:p,horizontal:d=!1,cache:T}=t;t=E({as:"div"},t);const e=N(t.data.length,p,void 0,T,!p),m=U(e,d),o=O(e,d),[s,_]=C(e.$getStateVersion());e.$subscribe(M,()=>{_(e.$getStateVersion())}),e.$subscribe(H,()=>{t.onScroll?.(e.$getScrollOffset())}),e.$subscribe(D,()=>{t.onScrollEnd?.()});const g=i(n=>{s();const r=e.$getRange(t.bufferSize);return n&&F(n,r)?n:r}),$=i(()=>s()&&e.$isScrolling()),S=i(()=>s()&&e.$getTotalSize()),b=i(()=>s()&&o.$isNegative());x(()=>{t.ref&&t.ref({get cache(){return e.$getCacheSnapshot()},get scrollOffset(){return e.$getScrollOffset()},get scrollSize(){return B(e)},get viewportSize(){return e.$getViewportSize()},findItemIndex:e.$findItemIndex,getItemOffset:e.$getItemOffset,getItemSize:e.$getItemSize,scrollToIndex:o.$scrollToIndex,scrollTo:o.$scrollTo,scrollBy:o.$scrollBy});const n=t.scrollRef||f.parentElement;m.$observeRoot(n),o.$observe(n),A(()=>{t.ref&&t.ref(),e.$dispose(),m.$dispose(),o.$dispose()})}),k(v(()=>t.startMargin||0,n=>{n!==e.$getStartSpacerSize()&&e.$update(J,n)})),q(v(s,()=>{o.$fixScrollJump()}));const y=i(()=>{const n=t.data.length;z(()=>{n!==e.$getItemsLength()&&e.$update(G,[n,t.shift])});const r=!d&&b()?"unshift":"push",u=[],c=[];if(t.keepMounted){const a=new Set(t.keepMounted);for(let[l,w]=g();l<=w;l++)a.add(l);j([...a]).forEach(l=>{u[r](t.data[l]),c[r](l)})}else for(let[a,l]=g();a<=l;a++)u[r](t.data[a]),c[r](a);return{_items:u,_indexes:c}}),I=(n,r)=>{const u=i(()=>(s(),e.$getItemOffset(r(),b()))),c=i(()=>(s(),e.$isUnmeasuredItem(r()))),a=i(()=>z(()=>t.children(n,r)));return h(P,{get _as(){return t.item},get _index(){return r()},get _resizer(){return m.$observeItem},get _offset(){return u()},get _hide(){return c()},get _children(){return a()},_isHorizontal:d})};return h(L,{get component(){return t.as},ref(n){var r=f;typeof r=="function"?r(n):f=n},get style(){return{contain:"size style","overflow-anchor":"none",flex:"none",position:"relative",width:d?S()+"px":"100%",height:d?"100%":S()+"px","pointer-events":$()?"none":void 0}},get children(){return h(R,{get each(){return y()._items},children:(n,r)=>{const u=i(()=>y()._indexes[r()]);return I(n,u)}})}})};try{V.displayName="Virtualizer",V.__docgenInfo={description:"Customizable list virtualizer for advanced usage. See {@link VirtualizerProps} and {@link VirtualizerHandle}.",displayName:"Virtualizer",props:{ref:{defaultValue:null,description:"Get reference to {@link VirtualizerHandle}.",name:"ref",required:!1,type:{name:"((handle?: VirtualizerHandle | undefined) => void) | undefined"}},data:{defaultValue:null,description:"The data items rendered by this component.",name:"data",required:!0,type:{name:"readonly T[]"}},children:{defaultValue:null,description:"The elements renderer function.",name:"children",required:!0,type:{name:"(data: T, index: Accessor<number>) => Element"}},bufferSize:{defaultValue:null,description:`Extra item space in pixels to render before/after the viewport. The minimum value is 0. Lower value will give better performance but you can increase to avoid showing blank items in fast scrolling.
@defaultValue 200`,name:"bufferSize",required:!1,type:{name:"number | undefined"}},as:{defaultValue:null,description:`Component or element type for container element.
@defaultValue "div"`,name:"as",required:!1,type:{name:"ValidComponent | undefined"}},item:{defaultValue:null,description:`Component or element type for item element.
@defaultValue "div"`,name:"item",required:!1,type:{name:"ValidComponent | undefined"}},scrollRef:{defaultValue:null,description:"Reference to the scrollable element. The default will get the direct parent element of virtualizer.",name:"scrollRef",required:!1,type:{name:"HTMLElement | undefined"}},itemSize:{defaultValue:null,description:`Item size hint for unmeasured items in pixels. It will help to reduce scroll jump when items are measured if used properly.

- If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.
- If set, you can opt out estimation and use the value as initial item size.`,name:"itemSize",required:!1,type:{name:"number | undefined"}},shift:{defaultValue:null,description:"While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.",name:"shift",required:!1,type:{name:"boolean | undefined"}},horizontal:{defaultValue:null,description:"If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.",name:"horizontal",required:!1,type:{name:"boolean | undefined"}},keepMounted:{defaultValue:null,description:"List of indexes that should be always mounted, even when off screen.",name:"keepMounted",required:!1,type:{name:"readonly number[] | undefined"}},cache:{defaultValue:null,description:`You can restore cache by passing a {@link CacheSnapshot} on mount. This is useful when you want to restore scroll position after navigation. The snapshot can be obtained from {@link VirtualizerHandle.cache}.

**The length of items should be the same as when you take the snapshot, otherwise restoration may not work as expected.**`,name:"cache",required:!1,type:{name:"CacheSnapshot | undefined"}},startMargin:{defaultValue:null,description:"The offset to the scrollable parent before virtualizer in pixels. If you put an element before virtualizer, you have to set its height to this prop.",name:"startMargin",required:!1,type:{name:"number | undefined"}},onScroll:{defaultValue:null,description:`Callback invoked whenever scroll offset changes.
@param offset Current scrollTop, or scrollLeft if horizontal: true.`,name:"onScroll",required:!1,type:{name:"((offset: number) => void) | undefined"}},onScrollEnd:{defaultValue:null,description:"Callback invoked when scrolling stops.",name:"onScrollEnd",required:!1,type:{name:"(() => void) | undefined"}}}}}catch{}export{V};
