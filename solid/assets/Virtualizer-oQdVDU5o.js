import{m as w,c as E,p as l,o as C,q as x,a as k,b as m,F as q,D as R,r as b,v as y,g as L}from"./iframe-D0JkJ_s3.js";import{c as A,a as N,U as O,b as M,d as H,e as D,L as U,i as P,A as F,s as G,g as j,f as B}from"./utils-CKjnA6S-.js";const z=t=>{let c;const{itemSize:h,horizontal:d=!1,cache:v}=t;t=w({as:"div"},t);const e=A(t.data.length,h,void 0,v,!h),f=D(e,d),o=N(e,d),[s,V]=E(e.$getStateVersion());e.$subscribe(O,()=>{V(e.$getStateVersion())}),e.$subscribe(M,()=>{t.onScroll?.(e.$getScrollOffset())}),e.$subscribe(H,()=>{t.onScrollEnd?.()});const p=l(n=>{s();const r=e.$getRange(t.bufferSize);return n&&P(n,r)?n:r}),T=l(()=>s()&&e.$isScrolling()),g=l(()=>s()&&e.$getTotalSize()),_=l(()=>s()&&o.$isNegative());C(()=>{t.ref&&t.ref({get cache(){return e.$getCacheSnapshot()},get scrollOffset(){return e.$getScrollOffset()},get scrollSize(){return j(e)},get viewportSize(){return e.$getViewportSize()},findItemIndex:e.$findItemIndex,getItemOffset:e.$getItemOffset,getItemSize:e.$getItemSize,scrollToIndex:o.$scrollToIndex,scrollTo:o.$scrollTo,scrollBy:o.$scrollBy});const n=c,r=t.scrollRef||n.parentElement;f.$observeRoot(r),o.$observe(n,r),L(()=>{t.ref&&t.ref(),e.$dispose(),f.$dispose(),o.$dispose()})}),x(y(()=>t.startMargin||0,n=>{n!==e.$getStartSpacerSize()&&e.$update(B,n)})),k(y(s,()=>{o.$fixScrollJump()}));const S=l(()=>{const n=t.data.length;b(()=>{n!==e.$getItemsLength()&&e.$update(F,[n,t.shift])});const r=[],u=[];if(t.keepMounted){const i=new Set(t.keepMounted);for(let[a,I]=p();a<=I;a++)i.add(a);G([...i]).forEach(a=>{r.push(t.data[a]),u.push(a)})}else for(let[i,a]=p();i<=a;i++)r.push(t.data[i]),u.push(i);return{_items:r,_indexes:u}}),$=(n,r)=>{const u=l(()=>(s(),e.$getItemOffset(r(),_()))),i=l(()=>(s(),e.$isUnmeasuredItem(r()))),a=l(()=>b(()=>t.children(n,r)));return m(U,{get _as(){return t.item},get _index(){return r()},get _resizer(){return f.$observeItem},get _offset(){return u()},get _hide(){return i()},get _children(){return a()},_isHorizontal:d})};return m(R,{get component(){return t.as},ref(n){var r=c;typeof r=="function"?r(n):c=n},get style(){return{contain:"size style","overflow-anchor":"none",flex:"none",position:"relative",width:d?g()+"px":"100%",height:d?"100%":g()+"px","pointer-events":T()?"none":void 0}},get children(){return m(q,{get each(){return S()._items},children:(n,r)=>{const u=l(()=>S()._indexes[r()]);return $(n,u)}})}})};try{z.displayName="Virtualizer",z.__docgenInfo={description:"Customizable list virtualizer for advanced usage. See {@link VirtualizerProps} and {@link VirtualizerHandle}.",displayName:"Virtualizer",props:{ref:{defaultValue:null,description:"Get reference to {@link VirtualizerHandle}.",name:"ref",required:!1,type:{name:"((handle?: VirtualizerHandle | undefined) => void) | undefined"}},data:{defaultValue:null,description:"The data items rendered by this component.",name:"data",required:!0,type:{name:"readonly T[]"}},children:{defaultValue:null,description:"The elements renderer function.",name:"children",required:!0,type:{name:"(data: T, index: Accessor<number>) => Element"}},bufferSize:{defaultValue:null,description:`Extra item space in pixels to render before/after the viewport. The minimum value is 0. Lower value will give better performance but you can increase to avoid showing blank items in fast scrolling.
@defaultValue 200`,name:"bufferSize",required:!1,type:{name:"number | undefined"}},as:{defaultValue:null,description:`Component or element type for container element.
@defaultValue "div"`,name:"as",required:!1,type:{name:"ValidComponent | undefined"}},item:{defaultValue:null,description:`Component or element type for item element.
@defaultValue "div"`,name:"item",required:!1,type:{name:"ValidComponent | undefined"}},scrollRef:{defaultValue:null,description:"Reference to the scrollable element. The default will get the direct parent element of virtualizer.",name:"scrollRef",required:!1,type:{name:"HTMLElement | undefined"}},itemSize:{defaultValue:null,description:`Item size hint for unmeasured items in pixels. It will help to reduce scroll jump when items are measured if used properly.

- If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.
- If set, you can opt out estimation and use the value as initial item size.`,name:"itemSize",required:!1,type:{name:"number | undefined"}},shift:{defaultValue:null,description:"While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.",name:"shift",required:!1,type:{name:"boolean | undefined"}},horizontal:{defaultValue:null,description:"If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.",name:"horizontal",required:!1,type:{name:"boolean | undefined"}},keepMounted:{defaultValue:null,description:"List of indexes that should be always mounted, even when off screen.",name:"keepMounted",required:!1,type:{name:"readonly number[] | undefined"}},cache:{defaultValue:null,description:`You can restore cache by passing a {@link CacheSnapshot} on mount. This is useful when you want to restore scroll position after navigation. The snapshot can be obtained from {@link VirtualizerHandle.cache}.

**The length of items should be the same as when you take the snapshot, otherwise restoration may not work as expected.**`,name:"cache",required:!1,type:{name:"CacheSnapshot | undefined"}},startMargin:{defaultValue:null,description:"The offset to the scrollable parent before virtualizer in pixels. If you put an element before virtualizer, you have to set its height to this prop.",name:"startMargin",required:!1,type:{name:"number | undefined"}},onScroll:{defaultValue:null,description:`Callback invoked whenever scroll offset changes.
@param offset Current scrollTop, or scrollLeft if horizontal: true.`,name:"onScroll",required:!1,type:{name:"((offset: number) => void) | undefined"}},onScrollEnd:{defaultValue:null,description:"Callback invoked when scrolling stops.",name:"onScrollEnd",required:!1,type:{name:"(() => void) | undefined"}}}}}catch{}export{z as V};
