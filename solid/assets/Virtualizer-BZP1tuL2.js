import{m as I,c as w,l,o as E,n as x,p as C,a as m,F as k,D as q,q as b,r as y,v as R}from"./iframe-CvHrSYf4.js";import{c as L,a as A,U as O,b as M,d as N,e as H,L as D,i as U,A as P,s as F,g as G,f as j}from"./utils-DGpVBcrF.js";const z=t=>{let c;const{itemSize:h,horizontal:u=!1,cache:V}=t;t=I({as:"div"},t);const e=L(t.data.length,h,void 0,V,!h),f=H(e,u),s=A(e,u),[d,v]=w(e.$getStateVersion());e.$subscribe(O,()=>{v(e.$getStateVersion())}),e.$subscribe(M,()=>{t.onScroll?.(e.$getScrollOffset())}),e.$subscribe(N,()=>{t.onScrollEnd?.()});const p=l(n=>{d();const r=e.$getRange(t.bufferSize);return n&&U(n,r)?n:r}),T=l(()=>d()&&e.$isScrolling()),g=l(()=>d()&&e.$getTotalSize());E(()=>{t.ref&&t.ref({get cache(){return e.$getCacheSnapshot()},get scrollOffset(){return e.$getScrollOffset()},get scrollSize(){return G(e)},get viewportSize(){return e.$getViewportSize()},findStartIndex:e.$findStartIndex,findEndIndex:e.$findEndIndex,getItemOffset:e.$getItemOffset,getItemSize:e.$getItemSize,scrollToIndex:s.$scrollToIndex,scrollTo:s.$scrollTo,scrollBy:s.$scrollBy});const n=t.scrollRef||c.parentElement;f.$observeRoot(n),s.$observe(n),R(()=>{t.ref&&t.ref(),e.$dispose(),f.$dispose(),s.$dispose()})}),x(y(()=>t.startMargin||0,n=>{n!==e.$getStartSpacerSize()&&e.$update(j,n)})),C(y(d,()=>{s.$fixScrollJump()}));const S=l(()=>{const n=t.data.length;b(()=>{n!==e.$getItemsLength()&&e.$update(P,[n,t.shift])});const r=[],o=[];if(t.keepMounted){const i=new Set(t.keepMounted);for(let[a,$]=p();a<=$;a++)i.add(a);F([...i]).forEach(a=>{r.push(t.data[a]),o.push(a)})}else for(let[i,a]=p();i<=a;i++)r.push(t.data[i]),o.push(i);return{_items:r,_indexes:o}}),_=(n,r)=>{const o=l(()=>(d(),e.$getItemOffset(r()))),i=l(()=>(d(),e.$isUnmeasuredItem(r()))),a=l(()=>b(()=>t.children(n,r)));return m(D,{get _as(){return t.item},get _index(){return r()},get _resizer(){return f.$observeItem},get _offset(){return o()},get _hide(){return i()},get _children(){return a()},_isHorizontal:u})};return m(q,{get component(){return t.as},ref(n){var r=c;typeof r=="function"?r(n):c=n},get style(){return{contain:"size paint style","overflow-anchor":"none",flex:"none",position:"relative",width:u?g()+"px":"100%",height:u?"100%":g()+"px","pointer-events":T()?"none":void 0}},get children(){return m(k,{get each(){return S()._items},children:(n,r)=>{const o=l(()=>S()._indexes[r()]);return _(n,o)}})}})};try{z.displayName="Virtualizer",z.__docgenInfo={description:"Customizable list virtualizer for advanced usage. See {@link VirtualizerProps} and {@link VirtualizerHandle}.",displayName:"Virtualizer",props:{ref:{defaultValue:null,description:"Get reference to {@link VirtualizerHandle}.",name:"ref",required:!1,type:{name:"((handle?: VirtualizerHandle | undefined) => void) | undefined"}},data:{defaultValue:null,description:"The data items rendered by this component.",name:"data",required:!0,type:{name:"readonly T[]"}},children:{defaultValue:null,description:"The elements renderer function.",name:"children",required:!0,type:{name:"(data: T, index: Accessor<number>) => Element"}},bufferSize:{defaultValue:null,description:`Extra item space in pixels to render before/after the viewport. The minimum value is 0. Lower value will give better performance but you can increase to avoid showing blank items in fast scrolling.
@defaultValue 200`,name:"bufferSize",required:!1,type:{name:"number | undefined"}},as:{defaultValue:null,description:`Component or element type for container element.
@defaultValue "div"`,name:"as",required:!1,type:{name:"ValidComponent | undefined"}},item:{defaultValue:null,description:`Component or element type for item element.
@defaultValue "div"`,name:"item",required:!1,type:{name:"ValidComponent | undefined"}},scrollRef:{defaultValue:null,description:"Reference to the scrollable element. The default will get the direct parent element of virtualizer.",name:"scrollRef",required:!1,type:{name:"HTMLElement | undefined"}},itemSize:{defaultValue:null,description:`Item size hint for unmeasured items in pixels. It will help to reduce scroll jump when items are measured if used properly.

- If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.
- If set, you can opt out estimation and use the value as initial item size.`,name:"itemSize",required:!1,type:{name:"number | undefined"}},shift:{defaultValue:null,description:"While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.",name:"shift",required:!1,type:{name:"boolean | undefined"}},horizontal:{defaultValue:null,description:"If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.",name:"horizontal",required:!1,type:{name:"boolean | undefined"}},keepMounted:{defaultValue:null,description:"List of indexes that should be always mounted, even when off screen.",name:"keepMounted",required:!1,type:{name:"readonly number[] | undefined"}},cache:{defaultValue:null,description:`You can restore cache by passing a {@link CacheSnapshot} on mount. This is useful when you want to restore scroll position after navigation. The snapshot can be obtained from {@link VirtualizerHandle.cache}.

**The length of items should be the same as when you take the snapshot, otherwise restoration may not work as expected.**`,name:"cache",required:!1,type:{name:"CacheSnapshot | undefined"}},startMargin:{defaultValue:null,description:"The offset to the scrollable parent before virtualizer in pixels. If you put an element before virtualizer, you have to set its height to this prop.",name:"startMargin",required:!1,type:{name:"number | undefined"}},onScroll:{defaultValue:null,description:`Callback invoked whenever scroll offset changes.
@param offset Current scrollTop, or scrollLeft if horizontal: true.`,name:"onScroll",required:!1,type:{name:"((offset: number) => void) | undefined"}},onScrollEnd:{defaultValue:null,description:"Callback invoked when scrolling stops.",name:"onScrollEnd",required:!1,type:{name:"(() => void) | undefined"}}}}}catch{}export{z as V};
