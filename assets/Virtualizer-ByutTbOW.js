import{j as _}from"./jsx-runtime-BjG_zV1W.js";import{r as i}from"./iframe-DTLkkNrr.js";import{a as k,u as M,A as X,j as G,b as R,r as s,U as B,c as F,d as K,m as Y,g as W,s as Q,e as Z,k as ee,l as te,n as ne}from"./useLatestRef-Bq73IlQz.js";import{u as se,L as oe}from"./useChildren-wcl3cCDG.js";import{r as re}from"./index-Dt0RuFuf.js";const ie=i.forwardRef(({children:V,count:L,overscan:O,itemSize:h,shift:q,horizontal:x,keepMounted:b,cache:A,startMargin:S=0,ssrCount:g,as:u="div",item:H="div",scrollRef:m,onScroll:N,onScrollEnd:P},j)=>{u=u;const[U,c]=se(V,L),y=i.useRef(null),T=i.useRef(!!g),v=k(N),I=k(P),[e,d,o,f]=M(()=>{const t=!!x,n=Z(c,h,O,g,A,!h);return[n,ee(n,t),te(n,t),t]});c!==e.$getItemsLength()&&e.$update(X,[c,q]),S!==e.$getStartSpacerSize()&&e.$update(G,S);const[D,w]=i.useReducer(e.$getStateVersion,void 0,e.$getStateVersion),[z,C]=e.$getRange(),J=e.$isScrolling(),E=e.$getTotalSize(),a=[],p=t=>{const n=U(t);return _.jsx(oe,{_resizer:d.$observeItem,_index:t,_offset:e.$getItemOffset(t),_hide:e.$isUnmeasuredItem(t),_as:H,_children:n,_isHorizontal:f,_isSSR:T[s]},ne(n,t))};R(()=>{T[s]=!1;const t=e.$subscribe(B,l=>{l?re.flushSync(w):w()}),n=e.$subscribe(F,()=>{v[s]&&v[s](e.$getScrollOffset())}),r=e.$subscribe(K,()=>{I[s]&&I[s]()}),$=l=>{d.$observeRoot(l),o.$observe(l)};return m?Y(()=>{m[s]&&$(m[s])}):$(y[s].parentElement),()=>{t(),n(),r(),d.$dispose(),o.$dispose()}},[]),R(()=>{o.$fixScrollJump()},[D]),i.useImperativeHandle(j,()=>({get cache(){return e.$getCacheSnapshot()},get scrollOffset(){return e.$getScrollOffset()},get scrollSize(){return W(e)},get viewportSize(){return e.$getViewportSize()},findStartIndex:e.$findStartIndex,findEndIndex:e.$findEndIndex,getItemOffset:e.$getItemOffset,getItemSize:e.$getItemSize,scrollToIndex:o.$scrollToIndex,scrollTo:o.$scrollTo,scrollBy:o.$scrollBy}),[]);for(let t=z,n=C;t<=n;t++)a.push(p(t));if(b){const t=[],n=[];Q(b).forEach(r=>{r<z&&t.push(p(r)),r>C&&n.push(p(r))}),a.unshift(...t),a.push(...n)}return _.jsx(u,{ref:y,style:{contain:"strict",overflowAnchor:"none",overflow:"clip",flex:"none",position:"relative",width:f?E:"100%",height:f?"100%":E,pointerEvents:J?"none":void 0},children:a})});ie.__docgenInfo={description:"Customizable list virtualizer for advanced usage. See {@link VirtualizerProps} and {@link VirtualizerHandle}.",methods:[{name:"cache",docblock:null,modifiers:["get"],params:[],returns:null},{name:"scrollOffset",docblock:null,modifiers:["get"],params:[],returns:null},{name:"scrollSize",docblock:null,modifiers:["get"],params:[],returns:null},{name:"viewportSize",docblock:null,modifiers:["get"],params:[],returns:null}],displayName:"Virtualizer",props:{children:{required:!0,tsType:{name:"union",raw:"ReactNode | ((index: number) => ReactElement)",elements:[{name:"ReactNode"},{name:"unknown"}]},description:`Elements rendered by this component.

You can also pass a function and set {@link VirtualizerProps.count} to create elements lazily.`},count:{required:!1,tsType:{name:"number"},description:"If you set a function to {@link VirtualizerProps.children}, you have to set total number of items to this prop."},overscan:{required:!1,tsType:{name:"number"},description:`Number of items to render above/below the visible bounds of the list. Lower value will give better performance but you can increase to avoid showing blank items in fast scrolling.
@defaultValue 4`},itemSize:{required:!1,tsType:{name:"number"},description:`Item size hint for unmeasured items. It will help to reduce scroll jump when items are measured if used properly.

- If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.
- If set, you can opt out estimation and use the value as initial item size.`},shift:{required:!1,tsType:{name:"boolean"},description:"While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling."},horizontal:{required:!1,tsType:{name:"boolean"},description:"If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list."},keepMounted:{required:!1,tsType:{name:"Array",elements:[{name:"number"}],raw:"number[]"},description:"List of indexes that should be always mounted, even when off screen."},cache:{required:!1,tsType:{name:"CacheSnapshot"},description:`You can restore cache by passing a {@link CacheSnapshot} on mount. This is useful when you want to restore scroll position after navigation. The snapshot can be obtained from {@link VirtualizerHandle.cache}.

**The length of items should be the same as when you take the snapshot, otherwise restoration may not work as expected.**`},startMargin:{required:!1,tsType:{name:"number"},description:"If you put an element before virtualizer, you have to define its height with this prop.",defaultValue:{value:"0",computed:!1}},ssrCount:{required:!1,tsType:{name:"number"},description:"A prop for SSR. If set, the specified amount of items will be mounted in the initial rendering regardless of the container size until hydrated."},as:{required:!1,tsType:{name:"union",raw:"keyof JSX.IntrinsicElements | CustomContainerComponent",elements:[{name:"JSX.IntrinsicElements"},{name:"ComponentType",elements:[{name:"CustomContainerComponentProps"}],raw:"ComponentType<CustomContainerComponentProps>"}]},description:`Component or element type for container element.
@defaultValue "div"`,defaultValue:{value:'"div"',computed:!1}},item:{required:!1,tsType:{name:"union",raw:"keyof JSX.IntrinsicElements | CustomItemComponent",elements:[{name:"JSX.IntrinsicElements"},{name:"ComponentType",elements:[{name:"CustomItemComponentProps"}],raw:"ComponentType<CustomItemComponentProps>"}]},description:`Component or element type for item element. This component will get {@link CustomItemComponentProps} as props.
@defaultValue "div"`,defaultValue:{value:'"div"',computed:!1}},scrollRef:{required:!1,tsType:{name:"RefObject",elements:[{name:"union",raw:"HTMLElement | null",elements:[{name:"HTMLElement"},{name:"null"}]}],raw:"RefObject<HTMLElement | null>"},description:"Reference to the scrollable element. The default will get the direct parent element of virtualizer."},onScroll:{required:!1,tsType:{name:"signature",type:"function",raw:"(offset: number) => void",signature:{arguments:[{type:{name:"number"},name:"offset"}],return:{name:"void"}}},description:`Callback invoked whenever scroll offset changes.
@param offset Current scrollTop, or scrollLeft if horizontal: true.`},onScrollEnd:{required:!1,tsType:{name:"signature",type:"function",raw:"() => void",signature:{arguments:[],return:{name:"void"}}},description:"Callback invoked when scrolling stops."}}};export{ie as V};
