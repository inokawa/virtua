import{j as w}from"./jsx-runtime-D_zvdyIk.js";import{r as o}from"./iframe-D5mdy-iQ.js";import{u as $,a as j,A as U,b as D,c as C,r,U as J,d as M,e as X,m as G,g as B,s as F,f as K,h as Y,i as W,j as Q}from"./useLatestRef-v5V7Khko.js";import{u as Z,L as ee}from"./useChildren-Wgg1ck1s.js";import{r as te}from"./index-BMl_gUJN.js";const ne=o.forwardRef(({children:E,data:k,bufferSize:d,itemSize:f,shift:_,horizontal:R,keepMounted:p,cache:V,startMargin:h=0,ssrCount:S,as:i="div",item:x="div",scrollRef:a,onScroll:L,onScrollEnd:O},q)=>{i=i;const[A,l]=Z(E,k),g=o.useRef(null),y=o.useRef(!!S),T=$(L),b=$(O),[e,m,s,u]=j(()=>{const t=!!R,n=K(l,f,S,V,!f);return[n,Y(n,t),W(n,t),t]});l!==e.$getItemsLength()&&e.$update(U,[l,_]),h!==e.$getStartSpacerSize()&&e.$update(D,h);const[H,v]=o.useReducer(e.$getStateVersion,void 0,e.$getStateVersion),N=e.$isScrolling(),I=e.$getTotalSize(),c=[],z=t=>{const n=A(t);return w.jsx(ee,{_resizer:m.$observeItem,_index:t,_offset:e.$getItemOffset(t),_hide:e.$isUnmeasuredItem(t),_as:x,_children:n,_isHorizontal:u,_isSSR:y[r]},Q(n,t))};if(C(()=>{y[r]=!1,e.$subscribe(J,n=>{n?te.flushSync(v):v()}),e.$subscribe(M,()=>{T[r]&&T[r](e.$getScrollOffset())}),e.$subscribe(X,()=>{b[r]&&b[r]()});const t=n=>{m.$observeRoot(n),s.$observe(n)};return a?G(()=>{a[r]&&t(a[r])}):t(g[r].parentElement),()=>{e.$dispose(),m.$dispose(),s.$dispose()}},[]),C(()=>{s.$fixScrollJump()},[H]),o.useImperativeHandle(q,()=>({get cache(){return e.$getCacheSnapshot()},get scrollOffset(){return e.$getScrollOffset()},get scrollSize(){return B(e)},get viewportSize(){return e.$getViewportSize()},findStartIndex:()=>e.$findItemIndex(e.$getStartSpacerSize()+e.$getScrollOffset()),findEndIndex:()=>e.$findItemIndex(e.$getStartSpacerSize()+e.$getScrollOffset()+e.$getViewportSize()),getItemOffset:e.$getItemOffset,getItemSize:e.$getItemSize,scrollToIndex:s.$scrollToIndex,scrollTo:s.$scrollTo,scrollBy:s.$scrollBy}),[]),p){const t=new Set(p);for(let[n,P]=e.$getRange(d);n<=P;n++)t.add(n);F([...t]).forEach(n=>{c.push(z(n))})}else for(let[t,n]=e.$getRange(d);t<=n;t++)c.push(z(t));return w.jsx(i,{ref:g,style:{contain:"size style",overflowAnchor:"none",flex:"none",position:"relative",width:u?I:"100%",height:u?"100%":I,pointerEvents:N?"none":void 0},children:c})});ne.__docgenInfo={description:"Customizable list virtualizer for advanced usage. See {@link VirtualizerProps} and {@link VirtualizerHandle}.",methods:[{name:"cache",docblock:null,modifiers:["get"],params:[],returns:null},{name:"scrollOffset",docblock:null,modifiers:["get"],params:[],returns:null},{name:"scrollSize",docblock:null,modifiers:["get"],params:[],returns:null},{name:"viewportSize",docblock:null,modifiers:["get"],params:[],returns:null},{name:"findStartIndex",docblock:null,modifiers:[],params:[],returns:null},{name:"findEndIndex",docblock:null,modifiers:[],params:[],returns:null}],displayName:"Virtualizer",props:{children:{required:!0,tsType:{name:"union",raw:"ReactNode | ((data: T, index: number) => ReactElement)",elements:[{name:"ReactNode"},{name:"unknown"}]},description:`Elements rendered by this component.

You can also pass a function and set {@link VirtualizerProps.data} to create elements lazily.`},data:{required:!1,tsType:{name:"ArrayLike",elements:[{name:"T"}],raw:"ArrayLike<T>"},description:"The data items rendered by this component. If you set a function to {@link VirtualizerProps.children}, you have to set this prop."},bufferSize:{required:!1,tsType:{name:"number"},description:`Extra item space in pixels to render before/after the viewport. The minimum value is 0. Lower value will give better performance but you can increase to avoid showing blank items in fast scrolling.
@defaultValue 200`},itemSize:{required:!1,tsType:{name:"number"},description:`Item size hint for unmeasured items in pixels. It will help to reduce scroll jump when items are measured if used properly.

- If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.
- If set, you can opt out estimation and use the value as initial item size.`},shift:{required:!1,tsType:{name:"boolean"},description:"While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling."},horizontal:{required:!1,tsType:{name:"boolean"},description:"If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list."},keepMounted:{required:!1,tsType:{name:"unknown"},description:"List of indexes that should be always mounted, even when off screen."},cache:{required:!1,tsType:{name:"CacheSnapshot"},description:`You can restore cache by passing a {@link CacheSnapshot} on mount. This is useful when you want to restore scroll position after navigation. The snapshot can be obtained from {@link VirtualizerHandle.cache}.

**The length of items should be the same as when you take the snapshot, otherwise restoration may not work as expected.**`},startMargin:{required:!1,tsType:{name:"number"},description:"The offset to the scrollable parent before virtualizer in pixels. If you put an element before virtualizer, you have to set its height to this prop.",defaultValue:{value:"0",computed:!1}},ssrCount:{required:!1,tsType:{name:"number"},description:"A prop for SSR. If set, the specified amount of items will be mounted in the initial rendering regardless of the container size until hydrated. The minimum value is 0."},as:{required:!1,tsType:{name:"union",raw:"keyof JSX.IntrinsicElements | CustomContainerComponent",elements:[{name:"JSX.IntrinsicElements"},{name:"ComponentType",elements:[{name:"CustomContainerComponentProps"}],raw:"ComponentType<CustomContainerComponentProps>"}]},description:`Component or element type for container element.
@defaultValue "div"`,defaultValue:{value:'"div"',computed:!1}},item:{required:!1,tsType:{name:"union",raw:"keyof JSX.IntrinsicElements | CustomItemComponent",elements:[{name:"JSX.IntrinsicElements"},{name:"ComponentType",elements:[{name:"CustomItemComponentProps"}],raw:"ComponentType<CustomItemComponentProps>"}]},description:`Component or element type for item element. This component will get {@link CustomItemComponentProps} as props.
@defaultValue "div"`,defaultValue:{value:'"div"',computed:!1}},scrollRef:{required:!1,tsType:{name:"RefObject",elements:[{name:"union",raw:"HTMLElement | null",elements:[{name:"HTMLElement"},{name:"null"}]}],raw:"RefObject<HTMLElement | null>"},description:"Reference to the scrollable element. The default will get the direct parent element of virtualizer."},onScroll:{required:!1,tsType:{name:"signature",type:"function",raw:"(offset: number) => void",signature:{arguments:[{type:{name:"number"},name:"offset"}],return:{name:"void"}}},description:`Callback invoked whenever scroll offset changes.
@param offset Current scrollTop, or scrollLeft if horizontal: true.`},onScrollEnd:{required:!1,tsType:{name:"signature",type:"function",raw:"() => void",signature:{arguments:[],return:{name:"void"}}},description:"Callback invoked when scrolling stops."}}};export{ne as V};
